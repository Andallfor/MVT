// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct doubleData {
    double cellSize, lat, lon, scale;
};

uint lenHeights, assignedLength, gridX, gridY, startX, startY, endX, endY, trueX, trueY, power;

// note: test with rwstructuredbuffer, rwbuffer, and rwbyteaddressbuffer
RWStructuredBuffer<int> heights;
RWStructuredBuffer<doubleData> data;
RWStructuredBuffer<float3> vectors;

// TODO: check performance of running code without if statements

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    uint idx = id.x * assignedLength;

    doubleData _d = data[0];

    double deg2rad = 3.14159265359 / 180.0;
    double rEq = 6378.14;
    double rPol = 6356.75;
    double aE = 6378.137;
    double eEsq = 0.00669437888014;

    double rEqXrEq = rEq * rEq;
    double rPolXrPol = rPol * rPol;

    double downscale = 1.0 / _d.scale;

    //double llLat = _d.lat + _d.cellSize * startY * power;
    //double llLon = _d.lon + _d.cellSize * startX * power;

    double maxHeight = trueY / power;

    for (uint i = 0; i < assignedLength; i++, idx++) {
        if (idx >= lenHeights) return;

        // maybe try converting everything to double to minimize type conversions?
        double x = double(idx % gridX);
        double y = double((idx - x) / gridX);

        double col = x + startX;
        double row = y + startY;

        double2 g = double2(col * _d.cellSize * power, -row * _d.cellSize * power);
        g.x += _d.lon;
        g.y += _d.lat + trueY * _d.cellSize;
        //double2 g = double2(llLon + power * x * _d.cellSize, llLat + power * y * _d.cellSize);
        //double2 g = double2(_d.lon + _d.cellSize * x, _d.lat + _d.cellSize * y);
        g.x *= deg2rad;
        g.y *= deg2rad;

        //float3 f = float3(
        //    6371.0 * cos(g.y) * cos(g.x) / _d.scale,
        //    6371.0 * cos(g.y) * sin(g.x) / _d.scale,
        //    6371.0 * sin(g.y) / _d.scale
        //);

        //vectors[idx] = float3(f.x, f.z, f.y);
        //continue;

        // what is the cost of allocating these vars?
        double cosLat = cos(g.y);
        double cosLon = cos(g.x);
        double sinLat = sin(g.y);
        double sinLon = sin(g.x);
        double a = (rEqXrEq * cosLat) * (rEqXrEq * cosLat);
        double b = (rPolXrPol * sinLat) * (rPolXrPol * sinLat);
        double c = (rEq * cosLat) * (rEq * cosLat);
        double d = (rPol * sinLat) * (rPol * sinLat);

        double rGs = sqrt((a + b) / (c + d));
        double nTheta = aE / sqrt(1.0 - eEsq * sinLat);

        double h = heights[idx];
        double gx = (nTheta + h) * cosLat * cosLon;
        double gy = (nTheta + h) * cosLat * sinLon;
        double gz = (nTheta * (1.0 - eEsq) + h) * sinLat;

        double n = sqrt(gx * gx + gy * gy + gz * gz);
        double hOffset = (h - 32767.0) / 1000.0;
        gx = (gx / n) * (rGs + hOffset) * downscale;
        gy = (gy / n) * (rGs + hOffset) * downscale;
        gz = (gz / n) * (rGs + hOffset) * downscale;

        vectors[idx] = float3(gx, gz, gy);
        //vectors[idx] = float3(x, 0, y);
    }
}
