#pragma kernel CSMain

uint2 meshCount, pointCount;
float2 llCorner;
float scale, cellsize, power, totalNRows;
float3 offsetPos;

RWStructuredBuffer<int> heights;
RWStructuredBuffer<float3> vectors;

[numthreads(128,1,1)] // SV_GroupThreadID, int j: SV_GroupID
void CSMain (uint3 id : SV_DispatchThreadID) {
    uint threadGroup = id.x / 128;
    uint meshIndex = threadGroup / 2;
    uint meshX = meshIndex % meshCount.x;
    uint meshY = (meshIndex - meshX) / meshCount.x;

    uint sx = meshX * 256;
    uint sy = meshY * 256;

    uint y = id.x % 256;
    uint fy = y + sy;

    if (fy >= pointCount.y) return;

    uint lx = min(pointCount.x - sx, 256);
    uint ly = min(pointCount.y - sy, 256);
    uint offset = sy * pointCount.x + sx * ly;

    const float deg2rad = 3.14159265359 / 180.0;
    const float rad2deg = 180.0 / 3.14159265359;
    const float rEq = 6378.14;
    const float rPol = 6356.75;
    const float aE = 6378.137;
    const float eEsq = 0.00669437888014;
    const float negEEsq = 0.99330562111986;
    const float rEqXrEq = rEq * rEq;
    const float rPolXrPol = rPol * rPol;
    const float downscale = 1.0 / scale;

    // todo: check cost of casting these vars
    for (uint x = 0; x < lx; x++) {
        float tx = sx + x - meshX;
        float ty = sy + y - meshY;
        uint ind = ty * pointCount.x + tx;

        float2 g = float2(tx * cellsize * power + llCorner.x, (totalNRows - ty * power) * cellsize + llCorner.y);
        g = float2(g.x * deg2rad, g.y * deg2rad);

        float cosLat = cos(g.y);
        float cosLon = cos(g.x);
        float sinLat = sin(g.y);
        float sinLon = sin(g.x);
        float a = (rEqXrEq * cosLat) * (rEqXrEq * cosLat);
        float b = (rPolXrPol * sinLat) * (rPolXrPol * sinLat);
        float c = (rEq * cosLat) * (rEq * cosLat);
        float d = (rPol * sinLat) * (rPol * sinLat);

        float rGs = sqrt((a + b) / (c + d));
        float nTheta = aE / sqrt(1.0 - eEsq * sinLat);

        float h = (heights[ind] - 32767.0) / 1000.0;
        float gx = (nTheta + h) * cosLat * cosLon;
        float gy = (nTheta + h) * cosLat * sinLon;
        float gz = (nTheta * negEEsq + h) * sinLat;

        float n = sqrt(gx * gx + gy * gy + gz * gz);
        gx = ((gx / n) * (rGs + h) + offsetPos.x) * downscale;
        gy = ((gy / n) * (rGs + h) + offsetPos.y) * downscale;
        gz = ((gz / n) * (rGs + h) + offsetPos.z) * downscale;

        vectors[offset + y * lx + x] = float3(gx, gz, gy);
    }
}
