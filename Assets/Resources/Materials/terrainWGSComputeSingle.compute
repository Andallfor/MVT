// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

struct doubleData {
    double cellSize, lat, lon, scale;
};

uint gridX, gridY, startX, startY, trueY, power;
uint2 mesh;

// note: test with rwstructuredbuffer, rwbuffer, and rwbyteaddressbuffer
RWStructuredBuffer<int> heights;
RWStructuredBuffer<doubleData> data;
RWStructuredBuffer<float3> vectors;

// TODO: check performance of running code without if statements

[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID) {
    uint meshIndex = (id.x - id.x % 128) / 128;
    uint xLength = (meshIndex + 1) % mesh.x == 0 ? gridX % 255 : 255;

    uint y = ceil(meshIndex / mesh.x);
    uint yLength = y * 128;
    if (yLength > gridY) yLength = 0;
    else if (yLength + 128 > gridY) yLength = yLength + 128 - gridY;
    else yLength = 128;

    if (id.x % 128 >= yLength) return;

    doubleData _d = data[0];

    double deg2rad = 3.14159265359 / 180.0;
    double rEq = 6378.14;
    double rPol = 6356.75;
    double aE = 6378.137;
    double eEsq = 0.00669437888014;

    double rEqXrEq = rEq * rEq;
    double rPolXrPol = rPol * rPol;

    double downscale = 1.0 / _d.scale;

    for (uint i = 0; i < xLength; i++) {
        uint x = i + (meshIndex % mesh.x) * 255;
        uint idx = y * gridX + x;

        double col = x + startX;
        double row = y + startY;

        double2 g = double2(col * _d.cellSize * power, -row * _d.cellSize * power);
        g.x += _d.lon;
        g.y += _d.lat + trueY * _d.cellSize;
        g.x *= deg2rad;
        g.y *= deg2rad;

        // what is the cost of allocating these vars?
        double cosLat = cos(g.y);
        double cosLon = cos(g.x);
        double sinLat = sin(g.y);
        double sinLon = sin(g.x);
        double a = (rEqXrEq * cosLat) * (rEqXrEq * cosLat);
        double b = (rPolXrPol * sinLat) * (rPolXrPol * sinLat);
        double c = (rEq * cosLat) * (rEq * cosLat);
        double d = (rPol * sinLat) * (rPol * sinLat);

        double rGs = sqrt((a + b) / (c + d));
        double nTheta = aE / sqrt(1.0 - eEsq * sinLat);

        double h = heights[idx];
        double gx = (nTheta + h) * cosLat * cosLon;
        double gy = (nTheta + h) * cosLat * sinLon;
        double gz = (nTheta * (1.0 - eEsq) + h) * sinLat;

        double n = sqrt(gx * gx + gy * gy + gz * gz);
        double hOffset = (h - 32767.0) / 1000.0;
        gx = (gx / n) * (rGs + hOffset) * downscale;
        gy = (gy / n) * (rGs + hOffset) * downscale;
        gz = (gz / n) * (rGs + hOffset) * downscale;

        vectors[idx] = float3(gx, gz, gy);
    }
}
